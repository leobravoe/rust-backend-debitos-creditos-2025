# =============================================================================
# ARQUIVO DOCKER COMPOSE — GUIA DIDÁTICO PARA INICIANTES
# -----------------------------------------------------------------------------
# Este arquivo descreve como iniciar vários serviços (containers) que trabalham
# juntos para formar um sistema completo. Use a leitura sequencial: primeiro a
# seção "services" (cada peça do sistema) e, ao final, "volumes" (onde ficam os
# dados persistentes). Não alteramos nada do conteúdo funcional; apenas
# adicionamos comentários explicativos longos e próximos de quase cada linha.
# =============================================================================

services:                       # Raiz que agrupa todos os serviços (cada serviço é um container com propósito próprio).

  postgres:                     # Serviço de banco de dados PostgreSQL; armazena dados da aplicação.
    image: postgres:15-alpine   # Imagem base do Postgres (versão 15) sobre Alpine Linux (leve, inicializa rápido).
    container_name: postgres    # Nome fixo do container; facilita achar logs ou executar comandos direcionados.
    restart: always             # Política de reinício automática: se o container parar/crashar, o Docker tenta subir novamente.

    environment:                # Variáveis de ambiente lidas pela imagem oficial do Postgres na inicialização.
      POSTGRES_USER: postgres           # Cria um usuário administrador chamado "postgres".
      POSTGRES_PASSWORD: postgres       # Define a senha do usuário acima; em produção, use um segredo forte.
      POSTGRES_DB: postgres_api_db      # Cria um banco inicial com esse nome para a aplicação usar.
      POSTGRES_HOST_AUTH_METHOD: trust  # Simplifica autenticação dentro da rede Docker (valor apenas para desenvolvimento).

    volumes:                    # Volumes mapeiam armazenamento persistente: dados sobrevivem mesmo que o container seja removido.
      - pgdata:/var/lib/postgresql/data                              # Guarda os arquivos reais do banco no volume "pgdata".
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro       # Executa script SQL inicial automaticamente na primeira criação.

    deploy:                     # Seção de “recursos” que descreve limites desejados (útil com Swarm; com --compatibility ajuda local).
      resources:
        limits:
          cpus: "0.80"          # Limita o uso de CPU a ~80% de um núcleo; ajuda a simular restrições de produção.
          memory: "250MB"       # Limita a memória a 250 MB; útil para evitar que o banco consuma todo o host.

    ports:                      # Mapeia portas do host → container para permitir acesso externo (do seu computador ao banco).
      - "5432:5432"             # A porta 5432 do host aponta para 5432 do Postgres dentro do container.

    healthcheck:                # Define como o Docker pode verificar se o serviço está *realmente pronto* para uso.
      test: [ "CMD-SHELL", "psql -U postgres -d postgres_api_db -tAc \"SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = '_init_done'\" | grep -q 1 && sleep 2" ]
                                # Comando de verificação: consulta se a tabela especial _init_done existe; se sim, dá “healthy”.
      interval: "5s"            # Frequência entre verificações de saúde (a cada 5 segundos).
      timeout: "5s"             # Tempo máximo para cada verificação antes de considerar falha.
      retries: 10               # Número de tentativas antes de marcar como “unhealthy”.
      start_period: "10s"       # Janela inicial de carência antes da primeira verificação (útil durante boot do Postgres).

  app1:                         # Primeira instância da aplicação (um worker). O balanceador pode enviar parte do tráfego para ela.
    build:                      # Em vez de baixar uma imagem pronta, o Compose vai construir a imagem a partir do Dockerfile.
      context: .                # Diretório de contexto do build; o “.” é a pasta onde está este docker-compose.yml.
      dockerfile: ./app/Dockerfile   # Caminho do Dockerfile a ser usado para construir a imagem da aplicação.
      args:
        BUILDKIT_INLINE_CACHE: 1     # Argumento de build para aproveitar caches em CI/CD; acelera builds subsequentes.
    container_name: app1        # Nome fixo para esta instância; útil em logs e diagnósticos.

    environment:                # Variáveis que a aplicação LÊ em tempo de execução para se configurar.
      PORT: 3001                      # Porta interna na qual o servidor HTTP da app escuta dentro do container.
      DB_HOST: postgres               # Host do banco dentro da rede Docker; usamos o nome do serviço, não “localhost”.
      DB_PORT: 5432                   # Porta interna do Postgres (a mesma exposta no serviço postgres).
      DB_USER: postgres               # Usuário do banco; deve combinar com o criado no Postgres.
      DB_PASSWORD: postgres           # Senha do banco; mantenha sincronizada com o Postgres (segredo forte em produção).
      DB_DATABASE: postgres_api_db    # Nome do banco que a app vai usar.
      PG_MIN: 5                       # Parâmetro customizado (mínimo de conexões no pool, por exemplo).
      PG_MAX: 10                      # Parâmetro customizado (máximo de conexões no pool).
      HOSTNAME: app1                  # Identificador lógico; pode aparecer em logs para rastrear qual instância atendeu a requisição.

    expose:                     # “Expõe” portas apenas para a rede interna do Docker (não abre no host).
      - "3001"                  # A outra aplicação (ex.: Nginx) pode alcançar app1:3001 via rede interna.

    healthcheck:                # Verificação de saúde HTTP simples para garantir que a app esteja respondendo.
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1 && sleep 2" ]
                                # Faz um GET local; se falhar, healthcheck retorna erro e o Docker marca como “unhealthy”.
      interval: "5s"            # Checa a cada 5 segundos.
      timeout: "5s"             # Se a resposta demorar mais de 5 segundos, considera falha.
      retries: 60               # Faz muitas tentativas (útil em subidas mais lentas).
      start_period: "60s"       # Tempo de carência antes de iniciar as checagens (a app pode demorar para iniciar).

    depends_on:                 # Controla a ordem de inicialização entre serviços.
      postgres:
        condition: service_healthy   # Só tenta subir app1 quando o Postgres estiver “healthy” (pronto segundo o healthcheck).

    deploy:                     # Declaração de limites desejados (ver nota do postgres para comportamento local vs Swarm).
      resources:
        limits:
          cpus: "0.25"          # Limita a ~25% de um núcleo; simula capacidade restrita.
          memory: "100MB"       # Limita a 100 MB de RAM; força a app a rodar enxuta.

    restart: unless-stopped     # Reinicia automaticamente em falhas, a menos que você interrompa manualmente.

  app2:                         # Segunda instância idêntica da aplicação; permite balancear carga entre duas cópias.
    build:                      # Mesmo processo de build da app1 para construir a imagem.
      context: .                # Mesmo diretório de contexto.
      dockerfile: ./app/Dockerfile   # Mesmo Dockerfile.
      args:
        BUILDKIT_INLINE_CACHE: 1     # Mesmo argumento de otimização de cache.
    container_name: app2        # Nome fixo para a segunda instância.

    environment:                # Variáveis de execução análogas à app1, com porta e hostname distintos.
      PORT: 3002                      # Esta instância escuta na porta interna 3002.
      DB_HOST: postgres               # Conecta ao mesmo banco de dados.
      DB_PORT: 5432                   # Mesma porta interna do Postgres.
      DB_USER: postgres               # Mesmo usuário do banco.
      DB_PASSWORD: postgres           # Mesma senha do banco.
      DB_DATABASE: postgres_api_db    # Mesmo banco de dados.
      PG_MIN: 5                       # Mesmo mínimo de conexões do pool.
      PG_MAX: 10                      # Mesmo máximo de conexões do pool.
      HOSTNAME: app2                  # Identifica esta instância como “app2” (útil para logs/comparações).

    expose:
      - "3002"                  # Expõe apenas para a rede interna; Nginx acessa app2:3002.

    healthcheck:                # Checagem de saúde da app2 (igual à app1, mas apontando para sua própria porta via $$PORT).
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1 && sleep 2" ]
      interval: "5s"
      timeout: "5s"
      retries: 60
      start_period: "60s"

    depends_on:                 # Garante que app2 só suba após o Postgres estar pronto.
      postgres:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: "0.25"          # Mesmo limite de CPU da app1 para manter simetria.
          memory: "100MB"       # Mesmo limite de memória da app1.
    restart: unless-stopped     # Mesmo comportamento de reinício automático.

  nginx:                        # Serviço de proxy reverso (porta de entrada do sistema para o “mundo externo”).
    image: nginx:alpine         # Imagem Nginx leve baseada em Alpine; inicia rápido e consome poucos recursos.
    container_name: nginx       # Nome fixo do container do Nginx.

    ports:                      # Mapeamento de porta do host para o Nginx.
      - "9999:9999"             # Acessar http://localhost:9999 no host envia tráfego para a porta 9999 dentro do container Nginx.

    healthcheck:                # Checagem de saúde do próprio Nginx (verifica se a rota de backend responde via proxy).
      test: [ "CMD-SHELL", "sleep 2 && curl -f http://localhost:$$PORT/clientes/1/extrato || exit 1" ]
                                # Verifica um endpoint de backend via Nginx; se falhar, marca o Nginx como “unhealthy”.
      interval: "5s"            # Periodicidade da verificação.
      timeout: "5s"             # Tempo máximo por verificação.
      retries: 60               # Quantidade de tentativas antes de considerar falha.
      start_period: "60s"       # Janela de carência para o Nginx aquecer antes das checagens.

    volumes:                    # Injeta a configuração personalizada do Nginx dentro do container.
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf   # Substitui o arquivo padrão pelo seu nginx.conf (deve existir no caminho informado).

    depends_on:                 # Controle de ordem: espera as aplicações estarem “healthy” antes de iniciar.
      app1:
        condition: service_healthy
      app2:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: "0.2"           # Limita o uso de CPU do Nginx; ele geralmente é leve.
          memory: "100MB"       # Limita a memória do Nginx para evitar picos inesperados.

    restart: unless-stopped     # Reinicia automaticamente, a menos que seja parado manualmente.

volumes:                        # Declaração formal dos volumes usados pelos serviços (armazenamento persistente gerenciado pelo Docker).
  pgdata:                       # Volume nomeado “pgdata”; é aqui que o Postgres mantém seus dados além do ciclo de vida do container.
